{"file_contents":{"seylane-instagram-explainer/index.js":{"content":"","size_bytes":0},"seylane-instagram-explainer/main.js":{"content":"const puppeteer = require(\"puppeteer-extra\");\nconst StealthPlugin = require(\"puppeteer-extra-plugin-stealth\");\nconst fetch = require(\"node-fetch\");\nconst { execSync } = require(\"child_process\");\npuppeteer.use(StealthPlugin());\n\n// Find chromium path dynamically\nconst getChromiumPath = () => {\n  try {\n    return execSync(\"which chromium\").toString().trim();\n  } catch (err) {\n    console.error(\"âŒ Chromium not found in PATH\");\n    process.exit(1);\n  }\n};\n\n// Helper function for delays (replaces deprecated page.waitForTimeout)\nconst delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\n// Helper function to take screenshots for debugging\nconst takeScreenshot = async (page, name) => {\n  try {\n    const filename = `debug_${name}_${Date.now()}.png`;\n    await page.screenshot({ path: filename, fullPage: true });\n    console.log(`ðŸ“¸ Screenshot saved: ${filename}`);\n    return filename;\n  } catch (err) {\n    console.error(\"Screenshot error:\", err.message);\n  }\n};\n\nconst {\n  OPENAI_API_KEY,\n  INSTAGRAM_USERNAME,\n  INSTAGRAM_PASSWORD,\n  INSTA_SESSION,\n} = process.env;\n\n(async () => {\n  console.log(\"ðŸš€ Seylane Instagram Explainer started...\");\n  const chromiumPath = getChromiumPath();\n  console.log(\"ðŸŒ Using chromium at:\", chromiumPath);\n\n  const browser = await puppeteer.launch({\n    headless: true,\n    executablePath: chromiumPath,\n    args: [\n      \"--no-sandbox\",\n      \"--disable-setuid-sandbox\",\n      \"--disable-dev-shm-usage\",\n      \"--single-process\",\n      \"--no-zygote\",\n    ],\n  });\n  const page = await browser.newPage();\n\n  if (INSTA_SESSION) {\n    console.log(\"ðŸª Using INSTA_SESSION cookie...\");\n    await page.setCookie({\n      name: \"sessionid\",\n      value: INSTA_SESSION,\n      domain: \".instagram.com\",\n      path: \"/\",\n      httpOnly: true,\n      secure: true,\n    });\n  }\n\n  console.log(\"ðŸ“± Navigating to Instagram...\");\n  await page.goto(\"https://www.instagram.com/\", { waitUntil: \"networkidle2\" });\n  await delay(4000);\n  await takeScreenshot(page, \"homepage\");\n\n  const loggedIn = await page.evaluate(\n    () => !!document.querySelector('a[href*=\"/direct/inbox\"]'),\n  );\n  console.log(`ðŸ” Login status: ${loggedIn ? \"Already logged in\" : \"Not logged in\"}`);\n\n  if (!loggedIn) {\n    console.log(\"ðŸ” Attempting to log in...\");\n    try {\n      await page.goto(\"https://www.instagram.com/accounts/login/\", {\n        waitUntil: \"networkidle2\",\n      });\n      await delay(2000);\n      await takeScreenshot(page, \"login_page\");\n\n      console.log(\"â³ Waiting for username input...\");\n      await page.waitForSelector('input[name=\"username\"]', { \n        visible: true,\n        timeout: 15000 \n      });\n      \n      console.log(\"âœï¸ Typing credentials...\");\n      await page.type('input[name=\"username\"]', INSTAGRAM_USERNAME, {\n        delay: 40,\n      });\n      await page.type('input[name=\"password\"]', INSTAGRAM_PASSWORD, {\n        delay: 40,\n      });\n      \n      await takeScreenshot(page, \"before_submit\");\n      console.log(\"ðŸš€ Clicking submit...\");\n      await page.click('button[type=\"submit\"]');\n      \n      await delay(3000);\n      await takeScreenshot(page, \"after_submit\");\n      \n      await page.waitForNavigation({ waitUntil: \"networkidle2\", timeout: 15000 }).catch((err) => {\n        console.log(\"âš ï¸ Navigation timeout (might be okay):\", err.message);\n      });\n      \n      await delay(2000);\n      await takeScreenshot(page, \"after_login\");\n      console.log(\"âœ… Login attempt completed\");\n    } catch (loginErr) {\n      console.error(\"âŒ Login failed:\", loginErr.message);\n      await takeScreenshot(page, \"login_error\");\n      throw new Error(`Login process failed: ${loginErr.message}`);\n    }\n  }\n\n  console.log(\"âœ… Logged in. Opening DMs...\");\n  try {\n    await page.goto(\"https://www.instagram.com/direct/inbox/\", {\n      waitUntil: \"networkidle2\",\n    });\n    await delay(4000);\n    \n    // Dismiss notification popup if it appears\n    try {\n      const notNowButton = await page.$x(\"//button[contains(text(), 'Not Now')]\");\n      if (notNowButton.length > 0) {\n        console.log(\"ðŸ”• Dismissing notification popup...\");\n        await notNowButton[0].click();\n        await delay(2000);\n      }\n    } catch (e) {\n      console.log(\"No notification popup to dismiss\");\n    }\n    \n    await takeScreenshot(page, \"dms_inbox\");\n    console.log(\"ðŸ“¬ DMs page loaded successfully\");\n  } catch (err) {\n    console.error(\"âŒ Failed to open DMs:\", err.message);\n    await takeScreenshot(page, \"dms_error\");\n    throw err;\n  }\n\n  // Affiliate link to send when user is ready\n  const AFFILIATE_LINK = \"https://affiliate.luxirana.com/account/login\";\n\n  async function askGPT(userMessage, username, conversationHistory = []) {\n    const systemPrompt = `\n    ØªÙˆ Â«Seylane ExplainerÂ» Ù‡Ø³ØªÛŒ - ÛŒÚ© Ù†Ù…Ø§ÛŒÙ†Ø¯Ù‡ Ø¨Ø§Ù‡ÙˆØ´ Ùˆ ØµÙ…ÛŒÙ…ÛŒ Ø¨Ø±Ù†Ø¯ Ø³ÛŒÙ„Ø§Ù†Ù‡.\n    \n    ÙˆØ¸ÛŒÙÙ‡ ØªÙˆ:\n    - Ø¨Ù‡ ØªÙ…Ø§Ù… Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ Ù¾Ø§Ø³Ø® Ø¨Ø¯Ù‡ØŒ Ù†Ù‡ ÙÙ‚Ø· Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ø¹Ù„Ø§Ù‚Ù‡â€ŒÙ…Ù†Ø¯ÛŒ\n    - Ù‡Ø± Ù¾Ø§Ø³Ø® Ø¨Ø§ÛŒØ¯ Ù…Ù†Ø­ØµØ± Ø¨Ù‡ ÙØ±Ø¯ Ùˆ Ø´Ø®ØµÛŒâ€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ø¯\n    - Ø§Ø² Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø± Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù† (${username || 'Ú©Ø§Ø±Ø¨Ø±'})\n    - Ù„Ø­Ù† Ø±Ø§ Ø¨Ø§ Ù„Ø­Ù† Ú©Ø§Ø±Ø¨Ø± ØªØ·Ø¨ÛŒÙ‚ Ø¨Ø¯Ù‡ (Ø±Ø³Ù…ÛŒ/ØºÛŒØ±Ø±Ø³Ù…ÛŒ)\n    - Ø§Ø­Ø³Ø§Ø³ ÛŒÚ© Ú¯ÙØªÚ¯ÙˆÛŒ Ø§Ù†Ø³Ø§Ù†ÛŒ Ùˆ Ø·Ø¨ÛŒØ¹ÛŒ Ø¨Ø¯Ù‡ØŒ Ù†Ù‡ Ù¾Ø§Ø³Ø® Ú©Ù¾ÛŒ-Ù¾ÛŒØ³Øª\n    \n    Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù‡Ù…Ú©Ø§Ø±ÛŒ Ø§ÙÛŒÙ„ÛŒØª Ø³ÛŒÙ„Ø§Ù†Ù‡:\n    - Ù‡Ù…Ú©Ø§Ø±ÛŒ Ù…Ø³ØªÙ‚ÛŒÙ… Ø¨Ø§ Ø¨Ø±Ù†Ø¯ Ø³ÛŒÙ„Ø§Ù†Ù‡ (Ø¨Ø¯ÙˆÙ† ÙˆØ§Ø³Ø·Ù‡)\n    - Ú©Ø¯ ØªØ®ÙÛŒÙ Û²Û° ØªØ§ Û´Û°Ùª Ø¨Ø±Ø§ÛŒ Ù…Ø®Ø§Ø·Ø¨Ø§Ù† Ø´Ù…Ø§\n    - Ù¾ÙˆØ±Ø³Ø§Ù†Øª Ù…Ø³ØªÙ‚ÛŒÙ… Ø§Ø² Ù‡Ø± Ø®Ø±ÛŒØ¯\n    - Ø¨Ø±Ù†Ø¯Ù‡Ø§: Misswake, Collamin, Umbrella, Dafi, IceBall\n    \n    ØªØ´Ø®ÛŒØµ Ù‚ØµØ¯ (Intent Detection):\n    - Ø§Ú¯Ø± Ú©Ø§Ø±Ø¨Ø± Ø¢Ù…Ø§Ø¯Ù‡ Ø´Ø±ÙˆØ¹ Ù‡Ù…Ú©Ø§Ø±ÛŒ Ø§Ø³Øª (Ù…Ø«Ù„ \"Ø¨ÙØ±Ø³Øª\"ØŒ \"Ù„ÛŒÙ†Ú© Ø¨Ø¯Ù‡\"ØŒ \"Ù…ÛŒâ€ŒØ®ÙˆØ§Ù… Ø´Ø±ÙˆØ¹ Ú©Ù†Ù…\"ØŒ \"Ø«Ø¨Øªâ€ŒÙ†Ø§Ù…\")\n      Ø¨Ø§ÛŒØ¯ Ø¯Ø± Ù¾Ø§Ø³Ø® JSONØŒ ÙÛŒÙ„Ø¯ \"sendLink\": true Ù‚Ø±Ø§Ø± Ø¨Ø¯Ù‡ÛŒ\n    - Ø¯Ø± ØºÛŒØ± Ø§ÛŒÙ† ØµÙˆØ±Øª \"sendLink\": false\n    \n    Ø®Ø±ÙˆØ¬ÛŒ Ø¨Ø§ÛŒØ¯ JSON Ø¨Ø§ Ø§ÛŒÙ† ÙØ±Ù…Øª Ø¨Ø§Ø´Ø¯:\n    {\n      \"message\": \"Ù…ØªÙ† Ù¾Ø§Ø³Ø® Ø´Ø®ØµÛŒâ€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯Ù‡\",\n      \"sendLink\": true/false\n    }\n    \n    Ù†Ú©Ø§Øª Ù…Ù‡Ù…:\n    - Ù‡Ø± Ù¾Ø§Ø³Ø® Ø¨Ø§ÛŒØ¯ Ù…ØªÙØ§ÙˆØª Ø¨Ø§Ø´Ø¯\n    - Ø§Ø² Ø§Ø³Ù… Ú©Ø§Ø±Ø¨Ø± Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†\n    - Ø¨Ù‡ Ø³ÙˆØ§Ù„Ø§Øª Ù…Ø´Ø®Øµ Ù¾Ø§Ø³Ø® Ù…Ø´Ø®Øµ Ø¨Ø¯Ù‡\n    - ØµÙ…ÛŒÙ…ÛŒØŒ Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ Ùˆ Ø§Ù†Ø³Ø§Ù†ÛŒ Ø¨Ø§Ø´\n    `;\n    \n    try {\n      const messages = [\n        { role: \"system\", content: systemPrompt }\n      ];\n      \n      // Add conversation history for context\n      if (conversationHistory.length > 0) {\n        conversationHistory.forEach(msg => {\n          messages.push(msg);\n        });\n      }\n      \n      // Add current user message\n      messages.push({ role: \"user\", content: userMessage });\n      \n      const res = await fetch(\"https://api.openai.com/v1/chat/completions\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${OPENAI_API_KEY}`,\n        },\n        body: JSON.stringify({\n          model: \"gpt-4o-mini\",\n          temperature: 0.9, // Higher temperature for more varied responses\n          messages: messages,\n        }),\n      });\n      \n      const data = await res.json();\n      const content = data?.choices?.[0]?.message?.content;\n      const parsed = JSON.parse(content);\n      \n      return {\n        message: parsed.message || content,\n        sendLink: parsed.sendLink || false\n      };\n    } catch (err) {\n      console.error(\"GPT Error:\", err.message);\n      return {\n        message: `Ø³Ù„Ø§Ù… ${username || 'Ø¹Ø²ÛŒØ²'}! ðŸŒ¿ Ø®ÙˆØ´Ø­Ø§Ù„Ù… Ú©Ù‡ Ù¾ÛŒØ§Ù…ØªÙˆÙ† Ø±Ùˆ Ø¯ÛŒØ¯Ù…. Ø¯Ø±Ø¨Ø§Ø±Ù‡ Ù‡Ù…Ú©Ø§Ø±ÛŒ Ø§ÙÛŒÙ„ÛŒØª Ø¨Ø§ Ø³ÛŒÙ„Ø§Ù†Ù‡ Ù…ÛŒâ€ŒØªÙˆÙ†Ù… Ú©Ù…Ú©ØªÙˆÙ† Ú©Ù†Ù…. Ù…Ø¯Ù„ Ù…Ø§ Ø®ÛŒÙ„ÛŒ Ø³Ø§Ø¯Ø³Øª: Ú©Ø¯ ØªØ®ÙÛŒÙ Û²Û° ØªØ§ Û´Û°Ùª Ø¨Ø±Ø§ÛŒ Ù…Ø®Ø§Ø·Ø¨Ø§Ù†ØªÙˆÙ† Ùˆ Ù¾ÙˆØ±Ø³Ø§Ù†Øª Ù…Ø³ØªÙ‚ÛŒÙ… Ø§Ø² ÙØ±ÙˆØ´. Ú†ÛŒØ²ÛŒ Ù‡Ø³Øª Ú©Ù‡ Ø¨Ø®ÙˆØ§Ù… Ø¨ÛŒØ´ØªØ± ØªÙˆØ¶ÛŒØ­ Ø¨Ø¯Ù…ØŸ âœ¨`,\n        sendLink: false\n      };\n    }\n  }\n\n  // Load persisted sent messages from file (survives restarts)\n  const SENT_MESSAGES_FILE = 'sent_messages.json';\n  let sentMessagesData = { messages: [], lastCleanup: Date.now() };\n  \n  try {\n    const fs = require('fs');\n    if (fs.existsSync(SENT_MESSAGES_FILE)) {\n      sentMessagesData = JSON.parse(fs.readFileSync(SENT_MESSAGES_FILE, 'utf8'));\n      console.log(`ðŸ“‚ Loaded ${sentMessagesData.messages.length} previously sent messages`);\n    }\n  } catch (err) {\n    console.log(\"ðŸ“‚ No previous sent messages found, starting fresh\");\n  }\n  \n  // Clean up old messages (keep only last 1000 and messages from last 7 days)\n  const SEVEN_DAYS = 7 * 24 * 60 * 60 * 1000;\n  sentMessagesData.messages = sentMessagesData.messages\n    .filter(m => Date.now() - m.timestamp < SEVEN_DAYS)\n    .slice(-1000);\n  \n  const sentMessages = new Set(sentMessagesData.messages.map(m => m.hash));\n  \n  // Helper to persist sent messages\n  function saveSentMessage(message) {\n    const hash = message.substring(0, 100);\n    sentMessages.add(hash);\n    sentMessagesData.messages.push({ hash, timestamp: Date.now() });\n    \n    // Apply retention trimming to prevent unbounded growth\n    const SEVEN_DAYS = 7 * 24 * 60 * 60 * 1000;\n    sentMessagesData.messages = sentMessagesData.messages\n      .filter(m => Date.now() - m.timestamp < SEVEN_DAYS)\n      .slice(-1000);\n    \n    // Save to file\n    try {\n      const fs = require('fs');\n      fs.writeFileSync(SENT_MESSAGES_FILE, JSON.stringify(sentMessagesData, null, 2));\n    } catch (err) {\n      console.error(\"âš ï¸ Failed to save sent messages:\", err.message);\n    }\n  }\n\n  console.log(\"ðŸ’¬ Listening for messages...\");\n  const replied = new Set(); // Track conversations we've replied to\n  let loopCount = 0;\n\n  while (true) {\n    try {\n      loopCount++;\n      console.log(`ðŸ”„ Checking messages (loop #${loopCount})...`);\n      \n      // Go back to inbox to see all conversations\n      await page.goto(\"https://www.instagram.com/direct/inbox/\", {\n        waitUntil: \"networkidle2\",\n        timeout: 30000\n      });\n      await delay(5000); // Wait longer for content to load\n      \n      // Dismiss notification popup if it appears (check every loop)\n      try {\n        // Wait a bit for popup to appear\n        await delay(1500);\n        \n        // Try to find and click \"Not Now\" button using page.evaluate\n        const dismissed = await page.evaluate(() => {\n          const buttons = Array.from(document.querySelectorAll('button'));\n          const notNowButton = buttons.find(btn => \n            btn.textContent.trim() === 'Not Now' ||\n            btn.textContent.includes('Not Now') ||\n            btn.textContent.includes('Not now') ||\n            btn.textContent.includes('Ø¨Ø¹Ø¯Ø§Ù‹') ||\n            btn.textContent.includes('Ù†Ù‡')\n          );\n          \n          if (notNowButton) {\n            notNowButton.click();\n            return true;\n          }\n          return false;\n        });\n        \n        if (dismissed) {\n          console.log(\"âœ… Notification popup dismissed - clicked 'Not Now'\");\n          await delay(3000); // Wait longer for popup to close and page to refresh\n        }\n      } catch (e) {\n        console.log(\"âš ï¸ Error dismissing popup:\", e.message);\n      }\n      \n      // Take screenshot to see current state\n      await takeScreenshot(page, \"before_finding_convs\");\n      \n      // Find clickable conversation elements by looking for the structure\n      const conversationElements = await page.evaluate(() => {\n        // Look for divs that contain conversation info\n        // Typically they have a structure with profile picture, name, and message preview\n        const allDivs = Array.from(document.querySelectorAll('div'));\n        \n        // Find divs that contain text matching conversation names\n        const clickable = allDivs.filter(div => {\n          const text = div.innerText;\n          // Look for divs that might be conversation items\n          // They usually have a name and time/message preview\n          return text && text.length > 2 && text.length < 200 && \n                 div.offsetParent !== null && // Is visible\n                 (div.role === 'button' || div.onclick || div.getAttribute('tabindex'));\n        });\n        \n        return {\n          totalDivs: allDivs.length,\n          clickableDivs: clickable.length,\n          sampleClicks: clickable.slice(0, 5).map(d => ({\n            text: d.innerText.substring(0, 50),\n            role: d.role,\n            hasClick: !!d.onclick\n          }))\n        };\n      });\n      \n      console.log(`ðŸ” DEBUG - Total divs: ${conversationElements.totalDivs}, Clickable: ${conversationElements.clickableDivs}`);\n      console.log(`ðŸ” Sample clickable elements:`, JSON.stringify(conversationElements.sampleClicks));\n      \n      // Try to click on visible conversation elements in the Primary tab\n      const conversationClicks = await page.evaluate(() => {\n        // Find all clickable divs that look like conversations\n        const convDivs = [];\n        const allDivs = Array.from(document.querySelectorAll('div[role=\"button\"]'));\n        \n        for (let div of allDivs) {\n          const text = div.innerText;\n          // Look for conversation pattern: has some text, is clickable, not too long\n          if (text && text.trim().length > 0 && text.length < 300) {\n            convDivs.push({\n              element: div,\n              preview: text.substring(0, 80)\n            });\n          }\n        }\n        \n        return convDivs.slice(0, 5).map(c => c.preview);\n      });\n      \n      console.log(`ðŸ“¬ Found ${conversationClicks.length} potential conversations`);\n      \n      // Check up to 5 conversations - re-query each time to avoid stale elements\n      const maxConvs = 5;\n      for (let convIndex = 0; convIndex < maxConvs; convIndex++) {\n        try {\n          console.log(`ðŸ“– Looking for conversation #${convIndex + 1}...`);\n          \n          // Re-query for conversation buttons each time\n          const convButton = await page.evaluate((index) => {\n            const buttons = Array.from(document.querySelectorAll('div[role=\"button\"]'));\n            \n            // Filter out tabs and UI buttons - look for conversation items\n            const conversations = buttons.filter(btn => {\n              const text = btn.innerText;\n              const role = btn.getAttribute('role');\n              \n              // Skip if it's a tab or has tab role\n              if (btn.closest('[role=\"tablist\"]')) return false;\n              if (text.includes('Primary') || text.includes('General') || text.includes('Requests')) return false;\n              if (text.includes('luxirana')) return false; // Skip username button\n              if (text.includes('Note')) return false; // Skip notes\n              \n              // Should have some reasonable text length for a conversation\n              return text && text.trim().length > 5 && text.length < 300;\n            });\n            \n            if (index < conversations.length) {\n              const btn = conversations[index];\n              const text = btn.innerText.substring(0, 60);\n              // Return info to identify this button for clicking\n              return {\n                found: true,\n                preview: text,\n                boundingBox: btn.getBoundingClientRect()\n              };\n            }\n            return { found: false };\n          }, convIndex);\n          \n          if (!convButton.found) {\n            console.log(`â„¹ï¸ No more conversations to check (found ${convIndex})`);\n            break;\n          }\n          \n          console.log(`ðŸ“¬ Found conversation: \"${convButton.preview}\"`);\n          \n          // Click on this conversation using coordinates\n          await page.evaluate((index) => {\n            const buttons = Array.from(document.querySelectorAll('div[role=\"button\"]'));\n            const conversations = buttons.filter(btn => {\n              const text = btn.innerText;\n              if (btn.closest('[role=\"tablist\"]')) return false;\n              if (text.includes('Primary') || text.includes('General') || text.includes('Requests')) return false;\n              if (text.includes('luxirana')) return false;\n              if (text.includes('Note')) return false;\n              return text && text.trim().length > 5 && text.length < 300;\n            });\n            if (index < conversations.length) {\n              conversations[index].click();\n            }\n          }, convIndex);\n          \n          await delay(4000); // Wait for conversation to fully load\n          \n          // Extract username and conversation data\n          const conversationData = await page.evaluate(() => {\n            // Get username from header or conversation title\n            let username = '';\n            const headerElements = document.querySelectorAll('header a, header span, h2, h3');\n            for (const el of headerElements) {\n              const text = el.innerText?.trim();\n              if (text && text.length > 0 && text.length < 50 && !text.includes('http')) {\n                username = text;\n                break;\n              }\n            }\n            \n            // Get all message containers - Instagram wraps messages in divs\n            // Incoming messages are typically in divs with specific positioning (left-aligned)\n            // Outgoing messages are in divs with different positioning (right-aligned)\n            const messageContainers = Array.from(document.querySelectorAll('div[role=\"row\"]'));\n            \n            let lastIncomingMessage = \"\";\n            let allUserMessages = [];\n            \n            // Try to identify incoming vs outgoing messages\n            // Instagram typically puts outgoing messages in containers with specific classes\n            // We'll look for messages that are NOT in the rightmost column\n            for (let i = messageContainers.length - 1; i >= 0; i--) {\n              const container = messageContainers[i];\n              const messageDiv = container.querySelector('div[dir=\"auto\"]');\n              \n              if (!messageDiv) continue;\n              \n              const messageText = messageDiv.innerText?.trim();\n              if (!messageText || messageText.length === 0 || messageText.length > 500) continue;\n              \n              // Check if this is an outgoing message by looking for specific patterns\n              // Outgoing messages typically have different container structures\n              const isOutgoing = container.querySelector('div[style*=\"justify-content: flex-end\"]') !== null ||\n                                container.querySelector('div[style*=\"flex-end\"]') !== null ||\n                                container.parentElement?.style?.justifyContent === 'flex-end';\n              \n              if (!isOutgoing && !lastIncomingMessage) {\n                lastIncomingMessage = messageText;\n              }\n              \n              if (!isOutgoing) {\n                allUserMessages.unshift(messageText);\n              }\n              \n              // Only collect last 5 user messages for context\n              if (allUserMessages.length >= 5) break;\n            }\n            \n            // Fallback: if we couldn't distinguish, look at all div[dir=\"auto\"] but be more conservative\n            if (!lastIncomingMessage) {\n              const allDivs = Array.from(document.querySelectorAll('div[dir=\"auto\"]'));\n              const potentialMessages = allDivs\n                .map(el => el.innerText?.trim())\n                .filter(text => text && text.length > 0 && text.length < 500);\n              \n              // Only consider the last message if there's at least 2 messages\n              // (to avoid immediately responding to our own message)\n              if (potentialMessages.length >= 2) {\n                lastIncomingMessage = potentialMessages[potentialMessages.length - 1];\n                allUserMessages = potentialMessages.slice(-5);\n              }\n            }\n            \n            // Get current URL to track this conversation\n            const conversationUrl = window.location.href;\n            \n            return {\n              username: username,\n              lastMessage: lastIncomingMessage,\n              allMessages: allUserMessages.slice(-5), // Last 5 user messages for context\n              conversationUrl: conversationUrl\n            };\n          });\n          \n          const { username, lastMessage, allMessages, conversationUrl } = conversationData;\n          \n          console.log(`ðŸ‘¤ Username: \"${username}\"`);\n          console.log(`ðŸ“¨ Last message: \"${lastMessage.substring(0, 50)}${lastMessage.length > 50 ? '...' : ''}\"`);\n          \n          // Check if we already replied to this conversation's last message\n          const conversationKey = `${conversationUrl}:${lastMessage}`;\n          \n          // Check if this is a message we sent (persisted across restarts)\n          const isSentByUs = sentMessages.has(lastMessage.substring(0, 100));\n          \n          // Check if this message is just the affiliate link (we sent it)\n          const isAffiliateLink = lastMessage.trim() === AFFILIATE_LINK;\n          \n          if (!lastMessage || lastMessage.length === 0) {\n            console.log(\"â„¹ï¸ No message found in this conversation, skipping...\");\n          } else if (isAffiliateLink) {\n            console.log(\"â„¹ï¸ This is the affiliate link we sent, skipping...\");\n            // Track it to prevent future replies\n            saveSentMessage(lastMessage);\n          } else if (isSentByUs) {\n            console.log(\"â„¹ï¸ This is our own message (tracked in persistence), skipping...\");\n          } else if (replied.has(conversationKey)) {\n            console.log(\"â„¹ï¸ Already replied to this message in current session, skipping...\");\n          } else {\n            console.log(\"ðŸ’¬ New message detected - generating personalized reply...\");\n            await takeScreenshot(page, \"incoming_message\");\n            \n            // Build conversation history for context\n            const conversationHistory = allMessages.slice(0, -1).map((msg, idx) => ({\n              role: idx % 2 === 0 ? 'user' : 'assistant',\n              content: msg\n            }));\n            \n            // Generate personalized AI response\n            const response = await askGPT(lastMessage, username, conversationHistory);\n            console.log(`ðŸ¤– GPT Reply: ${response.message.substring(0, 100)}...`);\n            console.log(`ðŸ”— Send affiliate link: ${response.sendLink}`);\n            \n            // Find and click the textarea\n            const textarea = await page.$('textarea[placeholder*=\"Message\"], textarea[aria-label*=\"Message\"], div[contenteditable=\"true\"]');\n            if (textarea) {\n              await textarea.click();\n              await delay(500);\n              \n              // Type the personalized message\n              await textarea.type(response.message, { delay: 50 });\n              await delay(500);\n              \n              // Press Enter to send\n              await page.keyboard.press(\"Enter\");\n              console.log(\"âœ… Sent personalized reply successfully!\");\n              \n              // Track this message as sent by us (persisted to file)\n              saveSentMessage(response.message);\n              \n              await delay(2000);\n              \n              // If user is ready, send the affiliate link\n              if (response.sendLink) {\n                console.log(\"ðŸ”— User is ready! Sending affiliate link...\");\n                await delay(1000);\n                \n                await textarea.click();\n                await delay(500);\n                await textarea.type(AFFILIATE_LINK, { delay: 30 });\n                await delay(500);\n                await page.keyboard.press(\"Enter\");\n                \n                console.log(\"âœ… Affiliate link sent!\");\n                \n                // Track the affiliate link as sent too (persisted)\n                saveSentMessage(AFFILIATE_LINK);\n                \n                await delay(1000);\n              }\n              \n              await takeScreenshot(page, \"reply_sent\");\n              replied.add(conversationKey);\n              \n              await delay(2000);\n            } else {\n              console.error(\"âŒ Could not find textarea to reply\");\n              await takeScreenshot(page, \"no_textarea\");\n            }\n          }\n          \n          // Go back to inbox for next conversation\n          console.log(\"ðŸ”™ Going back to inbox...\");\n          await page.goto(\"https://www.instagram.com/direct/inbox/\", {\n            waitUntil: \"networkidle2\",\n            timeout: 30000\n          });\n          await delay(3000);\n          \n          // Dismiss popup again if it appears\n          await page.evaluate(() => {\n            const buttons = Array.from(document.querySelectorAll('button'));\n            const notNowButton = buttons.find(btn => btn.textContent.includes('Not Now'));\n            if (notNowButton) notNowButton.click();\n          });\n          await delay(1000);\n          \n        } catch (e) {\n          console.log(`âš ï¸ Error checking conversation #${convIndex + 1}:`, e.message);\n          // Try to go back to inbox even on error\n          try {\n            await page.goto(\"https://www.instagram.com/direct/inbox/\", { waitUntil: \"networkidle2\", timeout: 30000 });\n            await delay(2000);\n          } catch {}\n        }\n      }\n      \n      console.log(\"âœ… Finished checking all conversations\");\n      await delay(20000); // Wait 20 seconds before next round\n    } catch (e) {\n      console.error(\"âŒ Loop Error:\", e.message);\n      await takeScreenshot(page, \"loop_error\").catch(() => {});\n      await delay(15000); // Wait longer on error\n    }\n  }\n})();\n","size_bytes":25903}},"version":2}